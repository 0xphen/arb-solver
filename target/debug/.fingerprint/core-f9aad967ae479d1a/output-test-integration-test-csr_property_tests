{"$message_type":"diagnostic","message":"failed to resolve: could not find `concat` in `core`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4666,"byte_end":4672,"line_start":162,"line_end":162,"column_start":29,"column_end":35,"is_primary":true,"text":[{"text":"                    ::core::concat!(::core::module_path!(), \"::\", ::core::stringify!($test_name)));","highlight_start":29,"highlight_end":35}],"label":"could not find `concat` in `core`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":5563,"byte_end":5736,"line_start":186,"line_end":190,"column_start":14,"column_end":6,"is_primary":false,"text":[{"text":"    )*) => { $crate::proptest! {","highlight_start":14,"highlight_end":33},{"text":"        #![proptest_config($crate::test_runner::Config::default())]","highlight_start":1,"highlight_end":68},{"text":"        $($(#[$meta])*","highlight_start":1,"highlight_end":23},{"text":"          fn $test_name($($parm in $strategy),+) $body)*","highlight_start":1,"highlight_end":57},{"text":"    } };","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":510,"byte_end":3095,"line_start":16,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"proptest! {","highlight_start":1,"highlight_end":12},{"text":"    /// Property: node_pointers should be monotonic","highlight_start":1,"highlight_end":52},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn node_pointers_monotonic(","highlight_start":1,"highlight_end":32},{"text":"        (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":49},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":66},{"text":"        for i in 0..csr.num_nodes {","highlight_start":1,"highlight_end":36},{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":1,"highlight_end":76},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: edge_targets and edge_weights length consistency","highlight_start":1,"highlight_end":71},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_arrays_length_consistent((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":84},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.edge_weights.len());","highlight_start":1,"highlight_end":76},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.node_pointers[csr.num_nodes]); // In CSR, the last node pointer equals the total number of edges.","highlight_start":1,"highlight_end":153},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: all edges are included (by count)","highlight_start":1,"highlight_end":56},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn all_edges_included((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":73},{"text":"    //   let size = edges.len();","highlight_start":1,"highlight_end":33},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), size);","highlight_start":1,"highlight_end":58},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property : Verifies the logarithmic transformation (-ln(rate)) is applied correctly","highlight_start":1,"highlight_end":95},{"text":"    // /// and that the weights are in the correct CSR order (sorted by source node).","highlight_start":1,"highlight_end":86},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_weights_transformed_correctly(","highlight_start":1,"highlight_end":46},{"text":"    //     (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":52},{"text":"    // ) {","highlight_start":1,"highlight_end":11},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut sorted_edges = edges;","highlight_start":1,"highlight_end":41},{"text":"    //     // The CSR constructor internally sorts by source node","highlight_start":1,"highlight_end":66},{"text":"    //     sorted_edges.sort_by_key(|e| e.0);","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let expected_weights: Vec<f64> = sorted_edges.iter().map(|&(_, _, r)| -r.ln()).collect();","highlight_start":1,"highlight_end":101},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     // Compares the final CSR weights to the correctly transformed and sorted input weights","highlight_start":1,"highlight_end":99},{"text":"    //     prop_assert_eq!(csr.edge_weights, expected_weights);","highlight_start":1,"highlight_end":64},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property: nodes with no outgoing edges have node_pointers[i] == node_pointers[i+1]","highlight_start":1,"highlight_end":94},{"text":"    // ///","highlight_start":1,"highlight_end":11},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn nodes_without_edges( (num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":75},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut has_edges = vec![false; num_nodes];","highlight_start":1,"highlight_end":55},{"text":"    //     for &(from, _, _) in &edges {","highlight_start":1,"highlight_end":41},{"text":"    //         if from < num_nodes { has_edges[from] = true; }","highlight_start":1,"highlight_end":63},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     for i in 0..num_nodes {","highlight_start":1,"highlight_end":35},{"text":"    //         if !has_edges[i] {","highlight_start":1,"highlight_end":34},{"text":"    //             prop_assert_eq!(csr.node_pointers[i], csr.node_pointers[i+1]);","highlight_start":1,"highlight_end":82},{"text":"    //         }","highlight_start":1,"highlight_end":17},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `concat` in `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:16:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mproptest! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Property: node_pointers should be monotonic\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[test]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn node_pointers_monotonic(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `concat` in `core`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::proptest` which comes from the expansion of the macro `proptest` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `stringify` in `core`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":32357,"byte_end":32366,"line_start":923,"line_end":923,"column_start":42,"column_end":51,"is_primary":true,"text":[{"text":"    (@_WRAPSTR ($item:pat)) => { ::core::stringify!($item) };","highlight_start":42,"highlight_end":51}],"label":"could not find `stringify` in `core`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":35137,"byte_end":35185,"line_start":968,"line_end":968,"column_start":21,"column_end":69,"is_primary":false,"text":[{"text":"        let names = $crate::proptest_helper!(@_WRAPSTR ($($parm),*));","highlight_start":21,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4754,"byte_end":4828,"line_start":163,"line_end":163,"column_start":17,"column_end":91,"is_primary":false,"text":[{"text":"                $crate::proptest_helper!(@_BODY config ($($parm in $strategy),+) [] $body);","highlight_start":17,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":5563,"byte_end":5736,"line_start":186,"line_end":190,"column_start":14,"column_end":6,"is_primary":false,"text":[{"text":"    )*) => { $crate::proptest! {","highlight_start":14,"highlight_end":33},{"text":"        #![proptest_config($crate::test_runner::Config::default())]","highlight_start":1,"highlight_end":68},{"text":"        $($(#[$meta])*","highlight_start":1,"highlight_end":23},{"text":"          fn $test_name($($parm in $strategy),+) $body)*","highlight_start":1,"highlight_end":57},{"text":"    } };","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":510,"byte_end":3095,"line_start":16,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"proptest! {","highlight_start":1,"highlight_end":12},{"text":"    /// Property: node_pointers should be monotonic","highlight_start":1,"highlight_end":52},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn node_pointers_monotonic(","highlight_start":1,"highlight_end":32},{"text":"        (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":49},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":66},{"text":"        for i in 0..csr.num_nodes {","highlight_start":1,"highlight_end":36},{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":1,"highlight_end":76},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: edge_targets and edge_weights length consistency","highlight_start":1,"highlight_end":71},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_arrays_length_consistent((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":84},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.edge_weights.len());","highlight_start":1,"highlight_end":76},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.node_pointers[csr.num_nodes]); // In CSR, the last node pointer equals the total number of edges.","highlight_start":1,"highlight_end":153},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: all edges are included (by count)","highlight_start":1,"highlight_end":56},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn all_edges_included((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":73},{"text":"    //   let size = edges.len();","highlight_start":1,"highlight_end":33},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), size);","highlight_start":1,"highlight_end":58},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property : Verifies the logarithmic transformation (-ln(rate)) is applied correctly","highlight_start":1,"highlight_end":95},{"text":"    // /// and that the weights are in the correct CSR order (sorted by source node).","highlight_start":1,"highlight_end":86},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_weights_transformed_correctly(","highlight_start":1,"highlight_end":46},{"text":"    //     (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":52},{"text":"    // ) {","highlight_start":1,"highlight_end":11},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut sorted_edges = edges;","highlight_start":1,"highlight_end":41},{"text":"    //     // The CSR constructor internally sorts by source node","highlight_start":1,"highlight_end":66},{"text":"    //     sorted_edges.sort_by_key(|e| e.0);","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let expected_weights: Vec<f64> = sorted_edges.iter().map(|&(_, _, r)| -r.ln()).collect();","highlight_start":1,"highlight_end":101},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     // Compares the final CSR weights to the correctly transformed and sorted input weights","highlight_start":1,"highlight_end":99},{"text":"    //     prop_assert_eq!(csr.edge_weights, expected_weights);","highlight_start":1,"highlight_end":64},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property: nodes with no outgoing edges have node_pointers[i] == node_pointers[i+1]","highlight_start":1,"highlight_end":94},{"text":"    // ///","highlight_start":1,"highlight_end":11},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn nodes_without_edges( (num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":75},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut has_edges = vec![false; num_nodes];","highlight_start":1,"highlight_end":55},{"text":"    //     for &(from, _, _) in &edges {","highlight_start":1,"highlight_end":41},{"text":"    //         if from < num_nodes { has_edges[from] = true; }","highlight_start":1,"highlight_end":63},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     for i in 0..num_nodes {","highlight_start":1,"highlight_end":35},{"text":"    //         if !has_edges[i] {","highlight_start":1,"highlight_end":34},{"text":"    //             prop_assert_eq!(csr.node_pointers[i], csr.node_pointers[i+1]);","highlight_start":1,"highlight_end":82},{"text":"    //         }","highlight_start":1,"highlight_end":17},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest_helper!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":29877,"byte_end":29905,"line_start":863,"line_end":863,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! proptest_helper {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest_helper!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":29877,"byte_end":29905,"line_start":863,"line_end":863,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! proptest_helper {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `stringify` in `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:16:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mproptest! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Property: node_pointers should be monotonic\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[test]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn node_pointers_monotonic(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `stringify` in `core`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::proptest_helper` which comes from the expansion of the macro `proptest` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `concat` in `core`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26671,"byte_end":26677,"line_start":750,"line_end":750,"column_start":45,"column_end":51,"is_primary":true,"text":[{"text":"        $crate::prop_assert!($cond, ::core::concat!(\"assertion failed: \", ::core::stringify!($cond)))","highlight_start":45,"highlight_end":51}],"label":"could not find `concat` in `core`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":789,"byte_end":851,"line_start":24,"line_end":24,"column_start":13,"column_end":75,"is_primary":false,"text":[{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":13,"highlight_end":75}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"prop_assert!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26571,"byte_end":26595,"line_start":748,"line_end":748,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! prop_assert {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `concat` in `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:24:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `concat` in `core`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `prop_assert` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `file` in `core`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26949,"byte_end":26953,"line_start":757,"line_end":757,"column_start":74,"column_end":78,"is_primary":true,"text":[{"text":"            let message = alloc::format!(\"{} at {}:{}\", message, ::core::file!(), ::core::line!());","highlight_start":74,"highlight_end":78}],"label":"could not find `file` in `core`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26635,"byte_end":26728,"line_start":750,"line_end":750,"column_start":9,"column_end":102,"is_primary":false,"text":[{"text":"        $crate::prop_assert!($cond, ::core::concat!(\"assertion failed: \", ::core::stringify!($cond)))","highlight_start":9,"highlight_end":102}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":789,"byte_end":851,"line_start":24,"line_end":24,"column_start":13,"column_end":75,"is_primary":false,"text":[{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":13,"highlight_end":75}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"prop_assert!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26571,"byte_end":26595,"line_start":748,"line_end":748,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! prop_assert {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::prop_assert!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26571,"byte_end":26595,"line_start":748,"line_end":748,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! prop_assert {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `file` in `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:24:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `file` in `core`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::prop_assert` which comes from the expansion of the macro `prop_assert` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `line` in `core`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26966,"byte_end":26970,"line_start":757,"line_end":757,"column_start":91,"column_end":95,"is_primary":true,"text":[{"text":"            let message = alloc::format!(\"{} at {}:{}\", message, ::core::file!(), ::core::line!());","highlight_start":91,"highlight_end":95}],"label":"could not find `line` in `core`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26635,"byte_end":26728,"line_start":750,"line_end":750,"column_start":9,"column_end":102,"is_primary":false,"text":[{"text":"        $crate::prop_assert!($cond, ::core::concat!(\"assertion failed: \", ::core::stringify!($cond)))","highlight_start":9,"highlight_end":102}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":789,"byte_end":851,"line_start":24,"line_end":24,"column_start":13,"column_end":75,"is_primary":false,"text":[{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":13,"highlight_end":75}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"prop_assert!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26571,"byte_end":26595,"line_start":748,"line_end":748,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! prop_assert {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::prop_assert!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26571,"byte_end":26595,"line_start":748,"line_end":748,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! prop_assert {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `line` in `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:24:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `line` in `core`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::prop_assert` which comes from the expansion of the macro `prop_assert` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `panic` in `core`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":35751,"byte_end":35756,"line_start":981,"line_end":981,"column_start":55,"column_end":60,"is_primary":true,"text":[{"text":"            ::core::result::Result::Err(e) => ::core::panic!(\"{}\\n{}\", e, runner),","highlight_start":55,"highlight_end":60}],"label":"could not find `panic` in `core`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4754,"byte_end":4828,"line_start":163,"line_end":163,"column_start":17,"column_end":91,"is_primary":false,"text":[{"text":"                $crate::proptest_helper!(@_BODY config ($($parm in $strategy),+) [] $body);","highlight_start":17,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":5563,"byte_end":5736,"line_start":186,"line_end":190,"column_start":14,"column_end":6,"is_primary":false,"text":[{"text":"    )*) => { $crate::proptest! {","highlight_start":14,"highlight_end":33},{"text":"        #![proptest_config($crate::test_runner::Config::default())]","highlight_start":1,"highlight_end":68},{"text":"        $($(#[$meta])*","highlight_start":1,"highlight_end":23},{"text":"          fn $test_name($($parm in $strategy),+) $body)*","highlight_start":1,"highlight_end":57},{"text":"    } };","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":510,"byte_end":3095,"line_start":16,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"proptest! {","highlight_start":1,"highlight_end":12},{"text":"    /// Property: node_pointers should be monotonic","highlight_start":1,"highlight_end":52},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn node_pointers_monotonic(","highlight_start":1,"highlight_end":32},{"text":"        (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":49},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":66},{"text":"        for i in 0..csr.num_nodes {","highlight_start":1,"highlight_end":36},{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":1,"highlight_end":76},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: edge_targets and edge_weights length consistency","highlight_start":1,"highlight_end":71},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_arrays_length_consistent((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":84},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.edge_weights.len());","highlight_start":1,"highlight_end":76},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.node_pointers[csr.num_nodes]); // In CSR, the last node pointer equals the total number of edges.","highlight_start":1,"highlight_end":153},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: all edges are included (by count)","highlight_start":1,"highlight_end":56},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn all_edges_included((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":73},{"text":"    //   let size = edges.len();","highlight_start":1,"highlight_end":33},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), size);","highlight_start":1,"highlight_end":58},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property : Verifies the logarithmic transformation (-ln(rate)) is applied correctly","highlight_start":1,"highlight_end":95},{"text":"    // /// and that the weights are in the correct CSR order (sorted by source node).","highlight_start":1,"highlight_end":86},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_weights_transformed_correctly(","highlight_start":1,"highlight_end":46},{"text":"    //     (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":52},{"text":"    // ) {","highlight_start":1,"highlight_end":11},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut sorted_edges = edges;","highlight_start":1,"highlight_end":41},{"text":"    //     // The CSR constructor internally sorts by source node","highlight_start":1,"highlight_end":66},{"text":"    //     sorted_edges.sort_by_key(|e| e.0);","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let expected_weights: Vec<f64> = sorted_edges.iter().map(|&(_, _, r)| -r.ln()).collect();","highlight_start":1,"highlight_end":101},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     // Compares the final CSR weights to the correctly transformed and sorted input weights","highlight_start":1,"highlight_end":99},{"text":"    //     prop_assert_eq!(csr.edge_weights, expected_weights);","highlight_start":1,"highlight_end":64},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property: nodes with no outgoing edges have node_pointers[i] == node_pointers[i+1]","highlight_start":1,"highlight_end":94},{"text":"    // ///","highlight_start":1,"highlight_end":11},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn nodes_without_edges( (num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":75},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut has_edges = vec![false; num_nodes];","highlight_start":1,"highlight_end":55},{"text":"    //     for &(from, _, _) in &edges {","highlight_start":1,"highlight_end":41},{"text":"    //         if from < num_nodes { has_edges[from] = true; }","highlight_start":1,"highlight_end":63},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     for i in 0..num_nodes {","highlight_start":1,"highlight_end":35},{"text":"    //         if !has_edges[i] {","highlight_start":1,"highlight_end":34},{"text":"    //             prop_assert_eq!(csr.node_pointers[i], csr.node_pointers[i+1]);","highlight_start":1,"highlight_end":82},{"text":"    //         }","highlight_start":1,"highlight_end":17},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest_helper!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":29877,"byte_end":29905,"line_start":863,"line_end":863,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! proptest_helper {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `panic` in `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:16:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mproptest! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Property: node_pointers should be monotonic\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[test]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn node_pointers_monotonic(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `panic` in `core`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::proptest_helper` which comes from the expansion of the macro `proptest` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `option` in `core`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4616,"byte_end":4622,"line_start":161,"line_end":161,"column_start":44,"column_end":50,"is_primary":true,"text":[{"text":"                config.test_name = ::core::option::Option::Some(","highlight_start":44,"highlight_end":50}],"label":"could not find `option` in `core`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":5563,"byte_end":5736,"line_start":186,"line_end":190,"column_start":14,"column_end":6,"is_primary":false,"text":[{"text":"    )*) => { $crate::proptest! {","highlight_start":14,"highlight_end":33},{"text":"        #![proptest_config($crate::test_runner::Config::default())]","highlight_start":1,"highlight_end":68},{"text":"        $($(#[$meta])*","highlight_start":1,"highlight_end":23},{"text":"          fn $test_name($($parm in $strategy),+) $body)*","highlight_start":1,"highlight_end":57},{"text":"    } };","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":510,"byte_end":3095,"line_start":16,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"proptest! {","highlight_start":1,"highlight_end":12},{"text":"    /// Property: node_pointers should be monotonic","highlight_start":1,"highlight_end":52},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn node_pointers_monotonic(","highlight_start":1,"highlight_end":32},{"text":"        (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":49},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":66},{"text":"        for i in 0..csr.num_nodes {","highlight_start":1,"highlight_end":36},{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":1,"highlight_end":76},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: edge_targets and edge_weights length consistency","highlight_start":1,"highlight_end":71},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_arrays_length_consistent((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":84},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.edge_weights.len());","highlight_start":1,"highlight_end":76},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.node_pointers[csr.num_nodes]); // In CSR, the last node pointer equals the total number of edges.","highlight_start":1,"highlight_end":153},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: all edges are included (by count)","highlight_start":1,"highlight_end":56},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn all_edges_included((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":73},{"text":"    //   let size = edges.len();","highlight_start":1,"highlight_end":33},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), size);","highlight_start":1,"highlight_end":58},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property : Verifies the logarithmic transformation (-ln(rate)) is applied correctly","highlight_start":1,"highlight_end":95},{"text":"    // /// and that the weights are in the correct CSR order (sorted by source node).","highlight_start":1,"highlight_end":86},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_weights_transformed_correctly(","highlight_start":1,"highlight_end":46},{"text":"    //     (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":52},{"text":"    // ) {","highlight_start":1,"highlight_end":11},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut sorted_edges = edges;","highlight_start":1,"highlight_end":41},{"text":"    //     // The CSR constructor internally sorts by source node","highlight_start":1,"highlight_end":66},{"text":"    //     sorted_edges.sort_by_key(|e| e.0);","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let expected_weights: Vec<f64> = sorted_edges.iter().map(|&(_, _, r)| -r.ln()).collect();","highlight_start":1,"highlight_end":101},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     // Compares the final CSR weights to the correctly transformed and sorted input weights","highlight_start":1,"highlight_end":99},{"text":"    //     prop_assert_eq!(csr.edge_weights, expected_weights);","highlight_start":1,"highlight_end":64},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property: nodes with no outgoing edges have node_pointers[i] == node_pointers[i+1]","highlight_start":1,"highlight_end":94},{"text":"    // ///","highlight_start":1,"highlight_end":11},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn nodes_without_edges( (num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":75},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut has_edges = vec![false; num_nodes];","highlight_start":1,"highlight_end":55},{"text":"    //     for &(from, _, _) in &edges {","highlight_start":1,"highlight_end":41},{"text":"    //         if from < num_nodes { has_edges[from] = true; }","highlight_start":1,"highlight_end":63},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     for i in 0..num_nodes {","highlight_start":1,"highlight_end":35},{"text":"    //         if !has_edges[i] {","highlight_start":1,"highlight_end":34},{"text":"    //             prop_assert_eq!(csr.node_pointers[i], csr.node_pointers[i+1]);","highlight_start":1,"highlight_end":82},{"text":"    //         }","highlight_start":1,"highlight_end":17},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider importing this enum","code":null,"level":"help","spans":[{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::option::Option;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `option` in `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:16:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mproptest! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Property: node_pointers should be monotonic\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[test]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn node_pointers_monotonic(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `option` in `core`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::proptest` which comes from the expansion of the macro `proptest` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing this enum\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::option::Option;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `result` in `core`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":27003,"byte_end":27009,"line_start":758,"line_end":758,"column_start":28,"column_end":34,"is_primary":true,"text":[{"text":"            return ::core::result::Result::Err(","highlight_start":28,"highlight_end":34}],"label":"could not find `result` in `core`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26635,"byte_end":26728,"line_start":750,"line_end":750,"column_start":9,"column_end":102,"is_primary":false,"text":[{"text":"        $crate::prop_assert!($cond, ::core::concat!(\"assertion failed: \", ::core::stringify!($cond)))","highlight_start":9,"highlight_end":102}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":789,"byte_end":851,"line_start":24,"line_end":24,"column_start":13,"column_end":75,"is_primary":false,"text":[{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":13,"highlight_end":75}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"prop_assert!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26571,"byte_end":26595,"line_start":748,"line_end":748,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! prop_assert {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::prop_assert!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":26571,"byte_end":26595,"line_start":748,"line_end":748,"column_start":1,"column_end":25,"is_primary":false,"text":[{"text":"macro_rules! prop_assert {","highlight_start":1,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::io::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::thread::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `result` in `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:24:13\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m24\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `result` in `core`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::prop_assert` which comes from the expansion of the macro `prop_assert` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing one of these items\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::fmt::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::io::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::result::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::thread::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `result` in `core`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":35599,"byte_end":35605,"line_start":977,"line_end":977,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"                ::core::result::Result::Ok(())","highlight_start":25,"highlight_end":31}],"label":"could not find `result` in `core`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4754,"byte_end":4828,"line_start":163,"line_end":163,"column_start":17,"column_end":91,"is_primary":false,"text":[{"text":"                $crate::proptest_helper!(@_BODY config ($($parm in $strategy),+) [] $body);","highlight_start":17,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":5563,"byte_end":5736,"line_start":186,"line_end":190,"column_start":14,"column_end":6,"is_primary":false,"text":[{"text":"    )*) => { $crate::proptest! {","highlight_start":14,"highlight_end":33},{"text":"        #![proptest_config($crate::test_runner::Config::default())]","highlight_start":1,"highlight_end":68},{"text":"        $($(#[$meta])*","highlight_start":1,"highlight_end":23},{"text":"          fn $test_name($($parm in $strategy),+) $body)*","highlight_start":1,"highlight_end":57},{"text":"    } };","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":510,"byte_end":3095,"line_start":16,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"proptest! {","highlight_start":1,"highlight_end":12},{"text":"    /// Property: node_pointers should be monotonic","highlight_start":1,"highlight_end":52},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn node_pointers_monotonic(","highlight_start":1,"highlight_end":32},{"text":"        (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":49},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":66},{"text":"        for i in 0..csr.num_nodes {","highlight_start":1,"highlight_end":36},{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":1,"highlight_end":76},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: edge_targets and edge_weights length consistency","highlight_start":1,"highlight_end":71},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_arrays_length_consistent((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":84},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.edge_weights.len());","highlight_start":1,"highlight_end":76},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.node_pointers[csr.num_nodes]); // In CSR, the last node pointer equals the total number of edges.","highlight_start":1,"highlight_end":153},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: all edges are included (by count)","highlight_start":1,"highlight_end":56},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn all_edges_included((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":73},{"text":"    //   let size = edges.len();","highlight_start":1,"highlight_end":33},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), size);","highlight_start":1,"highlight_end":58},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property : Verifies the logarithmic transformation (-ln(rate)) is applied correctly","highlight_start":1,"highlight_end":95},{"text":"    // /// and that the weights are in the correct CSR order (sorted by source node).","highlight_start":1,"highlight_end":86},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_weights_transformed_correctly(","highlight_start":1,"highlight_end":46},{"text":"    //     (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":52},{"text":"    // ) {","highlight_start":1,"highlight_end":11},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut sorted_edges = edges;","highlight_start":1,"highlight_end":41},{"text":"    //     // The CSR constructor internally sorts by source node","highlight_start":1,"highlight_end":66},{"text":"    //     sorted_edges.sort_by_key(|e| e.0);","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let expected_weights: Vec<f64> = sorted_edges.iter().map(|&(_, _, r)| -r.ln()).collect();","highlight_start":1,"highlight_end":101},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     // Compares the final CSR weights to the correctly transformed and sorted input weights","highlight_start":1,"highlight_end":99},{"text":"    //     prop_assert_eq!(csr.edge_weights, expected_weights);","highlight_start":1,"highlight_end":64},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property: nodes with no outgoing edges have node_pointers[i] == node_pointers[i+1]","highlight_start":1,"highlight_end":94},{"text":"    // ///","highlight_start":1,"highlight_end":11},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn nodes_without_edges( (num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":75},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut has_edges = vec![false; num_nodes];","highlight_start":1,"highlight_end":55},{"text":"    //     for &(from, _, _) in &edges {","highlight_start":1,"highlight_end":41},{"text":"    //         if from < num_nodes { has_edges[from] = true; }","highlight_start":1,"highlight_end":63},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     for i in 0..num_nodes {","highlight_start":1,"highlight_end":35},{"text":"    //         if !has_edges[i] {","highlight_start":1,"highlight_end":34},{"text":"    //             prop_assert_eq!(csr.node_pointers[i], csr.node_pointers[i+1]);","highlight_start":1,"highlight_end":82},{"text":"    //         }","highlight_start":1,"highlight_end":17},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest_helper!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":29877,"byte_end":29905,"line_start":863,"line_end":863,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! proptest_helper {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::io::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::thread::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `result` in `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:16:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mproptest! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Property: node_pointers should be monotonic\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[test]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn node_pointers_monotonic(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `result` in `core`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::proptest_helper` which comes from the expansion of the macro `proptest` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing one of these items\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::fmt::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::io::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::result::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::thread::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `result` in `core`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":35667,"byte_end":35673,"line_start":980,"line_end":980,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"            ::core::result::Result::Ok(()) => (),","highlight_start":21,"highlight_end":27}],"label":"could not find `result` in `core`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4754,"byte_end":4828,"line_start":163,"line_end":163,"column_start":17,"column_end":91,"is_primary":false,"text":[{"text":"                $crate::proptest_helper!(@_BODY config ($($parm in $strategy),+) [] $body);","highlight_start":17,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":5563,"byte_end":5736,"line_start":186,"line_end":190,"column_start":14,"column_end":6,"is_primary":false,"text":[{"text":"    )*) => { $crate::proptest! {","highlight_start":14,"highlight_end":33},{"text":"        #![proptest_config($crate::test_runner::Config::default())]","highlight_start":1,"highlight_end":68},{"text":"        $($(#[$meta])*","highlight_start":1,"highlight_end":23},{"text":"          fn $test_name($($parm in $strategy),+) $body)*","highlight_start":1,"highlight_end":57},{"text":"    } };","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":510,"byte_end":3095,"line_start":16,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"proptest! {","highlight_start":1,"highlight_end":12},{"text":"    /// Property: node_pointers should be monotonic","highlight_start":1,"highlight_end":52},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn node_pointers_monotonic(","highlight_start":1,"highlight_end":32},{"text":"        (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":49},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":66},{"text":"        for i in 0..csr.num_nodes {","highlight_start":1,"highlight_end":36},{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":1,"highlight_end":76},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: edge_targets and edge_weights length consistency","highlight_start":1,"highlight_end":71},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_arrays_length_consistent((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":84},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.edge_weights.len());","highlight_start":1,"highlight_end":76},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.node_pointers[csr.num_nodes]); // In CSR, the last node pointer equals the total number of edges.","highlight_start":1,"highlight_end":153},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: all edges are included (by count)","highlight_start":1,"highlight_end":56},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn all_edges_included((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":73},{"text":"    //   let size = edges.len();","highlight_start":1,"highlight_end":33},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), size);","highlight_start":1,"highlight_end":58},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property : Verifies the logarithmic transformation (-ln(rate)) is applied correctly","highlight_start":1,"highlight_end":95},{"text":"    // /// and that the weights are in the correct CSR order (sorted by source node).","highlight_start":1,"highlight_end":86},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_weights_transformed_correctly(","highlight_start":1,"highlight_end":46},{"text":"    //     (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":52},{"text":"    // ) {","highlight_start":1,"highlight_end":11},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut sorted_edges = edges;","highlight_start":1,"highlight_end":41},{"text":"    //     // The CSR constructor internally sorts by source node","highlight_start":1,"highlight_end":66},{"text":"    //     sorted_edges.sort_by_key(|e| e.0);","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let expected_weights: Vec<f64> = sorted_edges.iter().map(|&(_, _, r)| -r.ln()).collect();","highlight_start":1,"highlight_end":101},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     // Compares the final CSR weights to the correctly transformed and sorted input weights","highlight_start":1,"highlight_end":99},{"text":"    //     prop_assert_eq!(csr.edge_weights, expected_weights);","highlight_start":1,"highlight_end":64},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property: nodes with no outgoing edges have node_pointers[i] == node_pointers[i+1]","highlight_start":1,"highlight_end":94},{"text":"    // ///","highlight_start":1,"highlight_end":11},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn nodes_without_edges( (num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":75},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut has_edges = vec![false; num_nodes];","highlight_start":1,"highlight_end":55},{"text":"    //     for &(from, _, _) in &edges {","highlight_start":1,"highlight_end":41},{"text":"    //         if from < num_nodes { has_edges[from] = true; }","highlight_start":1,"highlight_end":63},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     for i in 0..num_nodes {","highlight_start":1,"highlight_end":35},{"text":"    //         if !has_edges[i] {","highlight_start":1,"highlight_end":34},{"text":"    //             prop_assert_eq!(csr.node_pointers[i], csr.node_pointers[i+1]);","highlight_start":1,"highlight_end":82},{"text":"    //         }","highlight_start":1,"highlight_end":17},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest_helper!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":29877,"byte_end":29905,"line_start":863,"line_end":863,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! proptest_helper {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::io::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::thread::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `result` in `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:16:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mproptest! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Property: node_pointers should be monotonic\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[test]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn node_pointers_monotonic(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `result` in `core`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::proptest_helper` which comes from the expansion of the macro `proptest` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing one of these items\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::fmt::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::io::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::result::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::thread::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"failed to resolve: could not find `result` in `core`","code":{"code":"E0433","explanation":"An undeclared crate, module, or type was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n\nIf you've expected to use a crate name:\n\n```compile_fail\nuse ferris_wheel::BigO;\n// error: failed to resolve: use of undeclared module or unlinked crate\n```\n\nMake sure the crate has been added as a dependency in `Cargo.toml`.\n\nTo use a module from your current crate, add the `crate::` prefix to the path.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":35717,"byte_end":35723,"line_start":981,"line_end":981,"column_start":21,"column_end":27,"is_primary":true,"text":[{"text":"            ::core::result::Result::Err(e) => ::core::panic!(\"{}\\n{}\", e, runner),","highlight_start":21,"highlight_end":27}],"label":"could not find `result` in `core`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4754,"byte_end":4828,"line_start":163,"line_end":163,"column_start":17,"column_end":91,"is_primary":false,"text":[{"text":"                $crate::proptest_helper!(@_BODY config ($($parm in $strategy),+) [] $body);","highlight_start":17,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":5563,"byte_end":5736,"line_start":186,"line_end":190,"column_start":14,"column_end":6,"is_primary":false,"text":[{"text":"    )*) => { $crate::proptest! {","highlight_start":14,"highlight_end":33},{"text":"        #![proptest_config($crate::test_runner::Config::default())]","highlight_start":1,"highlight_end":68},{"text":"        $($(#[$meta])*","highlight_start":1,"highlight_end":23},{"text":"          fn $test_name($($parm in $strategy),+) $body)*","highlight_start":1,"highlight_end":57},{"text":"    } };","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":510,"byte_end":3095,"line_start":16,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"proptest! {","highlight_start":1,"highlight_end":12},{"text":"    /// Property: node_pointers should be monotonic","highlight_start":1,"highlight_end":52},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn node_pointers_monotonic(","highlight_start":1,"highlight_end":32},{"text":"        (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":49},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":66},{"text":"        for i in 0..csr.num_nodes {","highlight_start":1,"highlight_end":36},{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":1,"highlight_end":76},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: edge_targets and edge_weights length consistency","highlight_start":1,"highlight_end":71},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_arrays_length_consistent((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":84},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.edge_weights.len());","highlight_start":1,"highlight_end":76},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.node_pointers[csr.num_nodes]); // In CSR, the last node pointer equals the total number of edges.","highlight_start":1,"highlight_end":153},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: all edges are included (by count)","highlight_start":1,"highlight_end":56},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn all_edges_included((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":73},{"text":"    //   let size = edges.len();","highlight_start":1,"highlight_end":33},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), size);","highlight_start":1,"highlight_end":58},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property : Verifies the logarithmic transformation (-ln(rate)) is applied correctly","highlight_start":1,"highlight_end":95},{"text":"    // /// and that the weights are in the correct CSR order (sorted by source node).","highlight_start":1,"highlight_end":86},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_weights_transformed_correctly(","highlight_start":1,"highlight_end":46},{"text":"    //     (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":52},{"text":"    // ) {","highlight_start":1,"highlight_end":11},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut sorted_edges = edges;","highlight_start":1,"highlight_end":41},{"text":"    //     // The CSR constructor internally sorts by source node","highlight_start":1,"highlight_end":66},{"text":"    //     sorted_edges.sort_by_key(|e| e.0);","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let expected_weights: Vec<f64> = sorted_edges.iter().map(|&(_, _, r)| -r.ln()).collect();","highlight_start":1,"highlight_end":101},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     // Compares the final CSR weights to the correctly transformed and sorted input weights","highlight_start":1,"highlight_end":99},{"text":"    //     prop_assert_eq!(csr.edge_weights, expected_weights);","highlight_start":1,"highlight_end":64},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property: nodes with no outgoing edges have node_pointers[i] == node_pointers[i+1]","highlight_start":1,"highlight_end":94},{"text":"    // ///","highlight_start":1,"highlight_end":11},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn nodes_without_edges( (num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":75},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut has_edges = vec![false; num_nodes];","highlight_start":1,"highlight_end":55},{"text":"    //     for &(from, _, _) in &edges {","highlight_start":1,"highlight_end":41},{"text":"    //         if from < num_nodes { has_edges[from] = true; }","highlight_start":1,"highlight_end":63},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     for i in 0..num_nodes {","highlight_start":1,"highlight_end":35},{"text":"    //         if !has_edges[i] {","highlight_start":1,"highlight_end":34},{"text":"    //             prop_assert_eq!(csr.node_pointers[i], csr.node_pointers[i+1]);","highlight_start":1,"highlight_end":82},{"text":"    //         }","highlight_start":1,"highlight_end":17},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest_helper!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":29877,"byte_end":29905,"line_start":863,"line_end":863,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! proptest_helper {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider importing one of these items","code":null,"level":"help","spans":[{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::fmt::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::io::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::result::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":null,"suggested_replacement":"use std::thread::Result;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m: failed to resolve: could not find `result` in `core`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:16:1\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mproptest! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Property: node_pointers should be monotonic\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[test]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn node_pointers_monotonic(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mcould not find `result` in `core`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::proptest_helper` which comes from the expansion of the macro `proptest` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider importing one of these items\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::fmt::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::io::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::result::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+ use std::thread::Result;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the size for values of type `[(usize, usize, f64)]` cannot be known at compilation time","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":638,"byte_end":647,"line_start":20,"line_end":20,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"        (num_nodes, mut edges) in csr_strategy()","highlight_start":21,"highlight_end":30}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the trait `std::marker::Sized` is not implemented for `[(usize, usize, f64)]`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"there are multiple different versions of crate `core` in the dependency graph\n","code":null,"level":"note","spans":[{"file_name":"/Users/kifen/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":5634,"byte_end":5649,"line_start":154,"line_end":154,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub trait Sized {","highlight_start":1,"highlight_end":16}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":"one version of crate `core` used here, as a dependency of crate `std`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":4,"byte_end":8,"line_start":1,"line_end":1,"column_start":5,"column_end":9,"is_primary":false,"text":[{"text":"use core::GraphCSR;","highlight_start":5,"highlight_end":9}],"label":"one version of crate `core` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/kifen/Dev/Rust/arb-solver/crates/core/src/traits.rs","byte_start":143,"byte_end":164,"line_start":5,"line_end":5,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub trait GraphSolver {","highlight_start":1,"highlight_end":22}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"all local variables must have a statically known size","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"unsized locals are gated as an unstable feature","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the size for values of type `[(usize, usize, f64)]` cannot be known at compilation time\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:20:21\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m20\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        (num_nodes, mut edges) in csr_strategy()\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdoesn't have a size known at compile-time\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: the trait `std::marker::Sized` is not implemented for `[(usize, usize, f64)]`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: there are \u001b[0m\u001b[0m\u001b[1m\u001b[35mmultiple different versions\u001b[0m\u001b[0m of crate `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcore\u001b[0m\u001b[0m` in the dependency graph\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/kifen/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:154:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m154\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait Sized {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the required trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `core` used here, as a dependency of crate `std`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:1:5\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse core::GraphCSR;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `core` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/kifen/Dev/Rust/arb-solver/crates/core/src/traits.rs:5:1\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait GraphSolver {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is the found trait\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcargo tree\u001b[0m\u001b[0m` to explore your dependency tree\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: all local variables must have a statically known size\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: unsized locals are gated as an unstable feature\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the size for values of type `[(usize, usize, f64)]` cannot be known at compilation time","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":35424,"byte_end":35523,"line_start":973,"line_end":974,"column_start":23,"column_end":69,"is_primary":true,"text":[{"text":"            $($mod)* |$crate::sugar::NamedArguments(","highlight_start":23,"highlight_end":53},{"text":"                _, $crate::proptest_helper!(@_WRAPPAT ($($parm),*)))|","highlight_start":1,"highlight_end":69}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4754,"byte_end":4828,"line_start":163,"line_end":163,"column_start":17,"column_end":91,"is_primary":false,"text":[{"text":"                $crate::proptest_helper!(@_BODY config ($($parm in $strategy),+) [] $body);","highlight_start":17,"highlight_end":91}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":5563,"byte_end":5736,"line_start":186,"line_end":190,"column_start":14,"column_end":6,"is_primary":false,"text":[{"text":"    )*) => { $crate::proptest! {","highlight_start":14,"highlight_end":33},{"text":"        #![proptest_config($crate::test_runner::Config::default())]","highlight_start":1,"highlight_end":68},{"text":"        $($(#[$meta])*","highlight_start":1,"highlight_end":23},{"text":"          fn $test_name($($parm in $strategy),+) $body)*","highlight_start":1,"highlight_end":57},{"text":"    } };","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":510,"byte_end":3095,"line_start":16,"line_end":79,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"proptest! {","highlight_start":1,"highlight_end":12},{"text":"    /// Property: node_pointers should be monotonic","highlight_start":1,"highlight_end":52},{"text":"    #[test]","highlight_start":1,"highlight_end":12},{"text":"    fn node_pointers_monotonic(","highlight_start":1,"highlight_end":32},{"text":"        (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":49},{"text":"    ) {","highlight_start":1,"highlight_end":8},{"text":"        let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":66},{"text":"        for i in 0..csr.num_nodes {","highlight_start":1,"highlight_end":36},{"text":"            prop_assert!(csr.node_pointers[i] <= csr.node_pointers[i + 1]);","highlight_start":1,"highlight_end":76},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: edge_targets and edge_weights length consistency","highlight_start":1,"highlight_end":71},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_arrays_length_consistent((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":84},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.edge_weights.len());","highlight_start":1,"highlight_end":76},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), csr.node_pointers[csr.num_nodes]); // In CSR, the last node pointer equals the total number of edges.","highlight_start":1,"highlight_end":153},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //  /// Property: all edges are included (by count)","highlight_start":1,"highlight_end":56},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn all_edges_included((num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":73},{"text":"    //   let size = edges.len();","highlight_start":1,"highlight_end":33},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"    //     prop_assert_eq!(csr.edge_targets.len(), size);","highlight_start":1,"highlight_end":58},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property : Verifies the logarithmic transformation (-ln(rate)) is applied correctly","highlight_start":1,"highlight_end":95},{"text":"    // /// and that the weights are in the correct CSR order (sorted by source node).","highlight_start":1,"highlight_end":86},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn edge_weights_transformed_correctly(","highlight_start":1,"highlight_end":46},{"text":"    //     (num_nodes, mut edges) in csr_strategy()","highlight_start":1,"highlight_end":52},{"text":"    // ) {","highlight_start":1,"highlight_end":11},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut sorted_edges = edges;","highlight_start":1,"highlight_end":41},{"text":"    //     // The CSR constructor internally sorts by source node","highlight_start":1,"highlight_end":66},{"text":"    //     sorted_edges.sort_by_key(|e| e.0);","highlight_start":1,"highlight_end":46},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let expected_weights: Vec<f64> = sorted_edges.iter().map(|&(_, _, r)| -r.ln()).collect();","highlight_start":1,"highlight_end":101},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     // Compares the final CSR weights to the correctly transformed and sorted input weights","highlight_start":1,"highlight_end":99},{"text":"    //     prop_assert_eq!(csr.edge_weights, expected_weights);","highlight_start":1,"highlight_end":64},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    // /// Property: nodes with no outgoing edges have node_pointers[i] == node_pointers[i+1]","highlight_start":1,"highlight_end":94},{"text":"    // ///","highlight_start":1,"highlight_end":11},{"text":"    // #[test]","highlight_start":1,"highlight_end":15},{"text":"    // fn nodes_without_edges( (num_nodes, mut edges) in csr_strategy()) {","highlight_start":1,"highlight_end":75},{"text":"    //     let csr = GraphCSR::from_edges(num_nodes, &mut edges, 5);","highlight_start":1,"highlight_end":69},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     let mut has_edges = vec![false; num_nodes];","highlight_start":1,"highlight_end":55},{"text":"    //     for &(from, _, _) in &edges {","highlight_start":1,"highlight_end":41},{"text":"    //         if from < num_nodes { has_edges[from] = true; }","highlight_start":1,"highlight_end":63},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    //     for i in 0..num_nodes {","highlight_start":1,"highlight_end":35},{"text":"    //         if !has_edges[i] {","highlight_start":1,"highlight_end":34},{"text":"    //             prop_assert_eq!(csr.node_pointers[i], csr.node_pointers[i+1]);","highlight_start":1,"highlight_end":82},{"text":"    //         }","highlight_start":1,"highlight_end":17},{"text":"    //     }","highlight_start":1,"highlight_end":13},{"text":"    // }","highlight_start":1,"highlight_end":9},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":4225,"byte_end":4246,"line_start":151,"line_end":151,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"macro_rules! proptest {","highlight_start":1,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::proptest_helper!","def_site_span":{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":29877,"byte_end":29905,"line_start":863,"line_end":863,"column_start":1,"column_end":29,"is_primary":false,"text":[{"text":"macro_rules! proptest_helper {","highlight_start":1,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"within `(usize, [(usize, usize, f64)])`, the trait `std::marker::Sized` is not implemented for `[(usize, usize, f64)]`","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"there are multiple different versions of crate `core` in the dependency graph\n","code":null,"level":"note","spans":[{"file_name":"/Users/kifen/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs","byte_start":5634,"byte_end":5649,"line_start":154,"line_end":154,"column_start":1,"column_end":16,"is_primary":true,"text":[{"text":"pub trait Sized {","highlight_start":1,"highlight_end":16}],"label":"this is the required trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":"one version of crate `core` used here, as a dependency of crate `std`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"crates/core/tests/csr_property_tests.rs","byte_start":4,"byte_end":8,"line_start":1,"line_end":1,"column_start":5,"column_end":9,"is_primary":false,"text":[{"text":"use core::GraphCSR;","highlight_start":5,"highlight_end":9}],"label":"one version of crate `core` used here, as a direct dependency of the current crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/Users/kifen/Dev/Rust/arb-solver/crates/core/src/traits.rs","byte_start":143,"byte_end":164,"line_start":5,"line_end":5,"column_start":1,"column_end":22,"is_primary":false,"text":[{"text":"pub trait GraphSolver {","highlight_start":1,"highlight_end":22}],"label":"this is the found trait","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can use `cargo tree` to explore your dependency tree","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required because it appears within the type `(usize, [(usize, usize, f64)])`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `proptest::sugar::NamedArguments`","code":null,"level":"note","spans":[{"file_name":"/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs","byte_start":39876,"byte_end":39877,"line_start":1074,"line_end":1074,"column_start":30,"column_end":31,"is_primary":true,"text":[{"text":"pub struct NamedArguments<N, V>(#[doc(hidden)] pub N, #[doc(hidden)] pub V);","highlight_start":30,"highlight_end":31}],"label":"required by this bound in `proptest::sugar::NamedArguments`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m: the size for values of type `[(usize, usize, f64)]` cannot be known at compilation time\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:16:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mproptest! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Property: node_pointers should be monotonic\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    #[test]\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m19\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    fn node_pointers_monotonic(\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m79\u001b[0m\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdoesn't have a size known at compile-time\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: within `(usize, [(usize, usize, f64)])`, the trait `std::marker::Sized` is not implemented for `[(usize, usize, f64)]`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: there are \u001b[0m\u001b[0m\u001b[1m\u001b[35mmultiple different versions\u001b[0m\u001b[0m of crate `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcore\u001b[0m\u001b[0m` in the dependency graph\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/kifen/.rustup/toolchains/stable-x86_64-apple-darwin/lib/rustlib/src/rust/library/core/src/marker.rs:154:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m154\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait Sized {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mthis is the required trait\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `core` used here, as a dependency of crate `std`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0mcrates/core/tests/csr_property_tests.rs:1:5\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse core::GraphCSR;\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mone version of crate `core` used here, as a direct dependency of the current crate\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m::: \u001b[0m\u001b[0m/Users/kifen/Dev/Rust/arb-solver/crates/core/src/traits.rs:5:1\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub trait GraphSolver {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m---------------------\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis is the found trait\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: you can use `\u001b[0m\u001b[0m\u001b[1m\u001b[35mcargo tree\u001b[0m\u001b[0m` to explore your dependency tree\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: required because it appears within the type `(usize, [(usize, usize, f64)])`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: required by a bound in `proptest::sugar::NamedArguments`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/kifen/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/proptest-1.8.0/src/sugar.rs:1074:30\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1074\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub struct NamedArguments<N, V>(#[doc(hidden)] pub N, #[doc(hidden)] pub V);\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10mrequired by this bound in `proptest::sugar::NamedArguments`\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `$crate::proptest_helper` which comes from the expansion of the macro `proptest` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 13 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 13 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0433.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0277, E0433.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
